# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info

if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_segmentation', [dirname(__file__)])
        except ImportError:
            import _segmentation
            return _segmentation
        if fp is not None:
            try:
                _mod = imp.load_module('_segmentation', fp, pathname, description)
            finally:
                fp.close()
            return _mod


    _segmentation = swig_import_helper()
    del swig_import_helper
else:
    import _segmentation
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method: return method(self, value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method: return method(self)
    raise AttributeError(name)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass


    _newclass = 0

import numpy as np


def make_4_grid(width, height):
    """Builds four connected grid graph for use with graph-cut code"""
    grid = np.zeros((width * height, 4))
    Self = np.arange(width * height)
    grid[:, 0] = Self + 1
    grid[:, 0].reshape((height, width)).T[width - 1] = -1
    #
    grid[:, 1] = Self - 1
    grid[:, 1].reshape((height, width)).T[0] = -1
    #
    grid[:, 2] = Self + width
    grid[:, 2].reshape((height, width))[height - 1] = -1
    #
    grid[:, 3] = Self - width
    grid[:, 3].reshape((height, width))[0] = -1
    grid[:, ::-1].sort(axis=1)
    return grid


def make_8_grid(width, height):
    """Builds eight connected grid graph for use with graph-cut code"""
    grid = np.zeros((width * height, 8))
    Self = np.arange(width * height)

    grid[:, 0] = Self + 1
    grid[:, 0].reshape((height, width)).T[width - 1] = -1

    grid[:, 1] = Self - 1
    grid[:, 1].reshape((height, width)).T[0] = -1

    grid[:, 2] = Self + width
    grid[:, 2].reshape((height, width))[height - 1] = -1

    grid[:, 3] = Self - width
    grid[:, 3].reshape((height, width))[0] = -1
    # We can reason about the following components by saying diagnals
    # must have two of the above components zeroed out corresponding
    # to the above directions
    grid[:, 4] = Self + 1 + width  # 1 and 3
    grid[:, 4].reshape((height, width)).T[width - 1] = -1
    grid[:, 4].reshape((height, width))[height - 1] = -1

    grid[:, 5] = Self + 1 - width  # 1 and 4
    grid[:, 5].reshape((height, width)).T[width - 1] = -1
    grid[:, 5].reshape((height, width))[0] = -1

    grid[:, 6] = Self - 1 + width  # 2 and 3
    grid[:, 6].reshape((height, width)).T[0] = -1
    grid[:, 6].reshape((height, width))[height - 1] = -1

    grid[:, 7] = Self - 1 - width  # 2 and 4
    grid[:, 7].reshape((height, width)).T[0] = -1
    grid[:, 7].reshape((height, width))[0] = -1
    grid[:, ::-1].sort(axis=1)
    return grid


def allgc(unary, nhood, ncost, noverlap, mdl,
          current_label, exterior_weight=1, outlier=np.Inf):
    """Graph-cut based segmentation algorithm that combines alpha-expansion (see expand) with overlapping models(see multi) and an MDL prior.
Takes as input a unary cost matrix [variables*labels], pairwise neighbourhood structure [variables*maxnhood_size], neighbourhood weighting function for a Potts based CRF of the same size [variables*maxnhood_size], overlapping nhood[variables*max_overlap_nhood_size] mdl costs[labels] current_labels[variables], exterior weight >= 0 (suggested 1), and outlier rejection level >= 0 (suggested Inf).

Returns an overlapping mask multi[variables*labels], and interior labels assignment[variables]. """
    from numpy import zeros
    maskout = zeros(unary.shape)
    labelsout = zeros(unary.shape[0])
    _allgc(maskout, labelsout, unary, nhood, ncost, noverlap,
           mdl, current_label, exterior_weight, outlier)
    return [maskout, labelsout]


def expand(unary, nhood, ncost,
           mdl, current_label, outlier=np.Inf):
    """Implements standard alpha-expansion of edge-weighted Potts model along with MDL prior"""
    assert (unary.ndim == 2)
    assert (current_label.ndim == 1)
    assert (mdl.ndim == 1)
    assert (nhood.ndim == 2)
    from numpy import zeros
    maskout = zeros(unary.shape)
    labelsout = zeros(unary.shape[0])
    _expand(maskout, labelsout, unary, nhood, ncost,
            mdl, current_label, outlier)
    return [maskout, labelsout]


def multi(unary, noverlap,
          mdl, current_label, exterior_weight=1, outlier=np.Inf):
    """Implements standard overlapping model code of CVPR11 paper"""
    assert (unary.ndim == 2)
    assert (current_label.ndim == 1)
    assert (mdl.ndim == 1)
    assert (noverlap.ndim == 2)
    from numpy import zeros
    maskout = zeros(unary.shape)
    labelsout = zeros(unary.shape[0])
    _multi(maskout, labelsout, unary, noverlap,
           mdl, current_label, exterior_weight, outlier)
    return [maskout, labelsout]


def multi_thresh(unary, noverlap,
                 mdl, current_label, thresh, exterior_weight=1, outlier=np.Inf):
    """Implements standard overlapping model code of CVPR11 paper+ Boundary rejection"""
    assert (unary.ndim == 2)
    assert (current_label.ndim == 1)
    assert (mdl.ndim == 1)
    assert (noverlap.ndim == 2)
    assert (thresh.shape == unary.shape[0])
    from numpy import zeros
    maskout = zeros(unary.shape)
    labelsout = zeros(unary.shape[0])
    _multi_thresh(maskout, labelsout, unary, noverlap,
                  mdl, current_label, thresh, exterior_weight, outlier)
    return [maskout, labelsout]


def kmeans(image, xmeans, ymeans, xweight, yweight, it=2):
    assert (image.ndim == 3)
    assert (image.shape[2] == 3)
    from numpy import zeros
    assign = zeros((image.shape[0], image.shape[1]), dtype=np.double)
    means = zeros((xmeans * ymeans, image.shape[2] + 2), dtype=np.double)
    _kmeans(assign, means, np.double(image), xmeans, ymeans, xweight, yweight, it)
    return assign, means


def vis(image, assign):
    """Visualises super-pixels as averaged image intensities over each label plus black border"""
    assert (image.ndim == 3)
    assert (image.shape[2] == 3)
    assert (assign.ndim == 2)
    from numpy import zeros
    out = zeros(image.shape)
    _vis(np.double(assign), np.double(image), out)
    return out


def vis_col(assign):
    """Recoloured labels"""
    assert (assign.ndim == 2)
    from numpy import zeros
    out = zeros((assign.shape[0], assign.shape[1], 3), np.double)
    _vis_col(assign, out)
    return out


def filter(mask, match, index, scale_by, to_filter, out):
    assert (mask.ndim == 2)
    assert (index.ndim == 2)
    assert (to_filter.ndim == 2)
    assert (out.ndim == 2)
    assert (mask.shape == index.shape)
    a = _filter(mask, match, index, scale_by, to_filter, out)
    return out[0:a, :]


def filter_sum(mask, match, index, scale_by, to_filter, out):
    assert (mask.ndim == 2)
    assert (index.ndim == 2)
    assert (to_filter.ndim == 2)
    assert (out.ndim == 2)
    assert (out.shape[0] == to_filter.shape[1])
    assert (out.shape[0] == out.shape[1])
    assert (mask.shape == index.shape)
    a = _filter_sum(mask, match, index, scale_by, to_filter, out)
    return out[0:a, :]


def clump(unary, patches, thresh=np.inf):
    """Agregates unary potentials according to the partition given in patches
    Use this to move from dense unary costs to super-pixel based segmentation"""
    unary = unary.T.copy()
    patches = patches.reshape(patches.size)
    out = np.zeros((patches.max() + 1, unary.shape[1]), np.double)
    _clump(out, unary, patches, thresh)
    return out


def inv_clump(labels, minpatches):
    """Transform a super-pixel labelling into an image labelling"""
    return labels[np.int32(minpatches)]


def vis_col_2(image, assign):
    """Recoloured labels but preserving greyscale intensities behind the image."""
    assert (image.ndim == 3)
    assert (image.shape[2] == 3)
    assert (assign.ndim == 2)
    from numpy import zeros
    out = zeros(image.shape)
    _vis_col_2(np.double(assign), np.double(image), out)
    return out


def quick_vis(myimage, labels, caption=""):
    """Plot labelling labels as a new figure that overlays  myimage"""
    from matplotlib import pyplot as plt
    plt.figure()
    plt.imshow(vis_col_2(
        myimage, labels.reshape(myimage.shape[0], myimage.shape[1])))
    plt.text(100, 0, caption, color='red')
    plt.axis('off')


def unary_cost(E, label):
    """Given a labelling, return the vector of unary costs associated with it"""
    x, y = E.shape
    assert (y == label.size)
    temp = E.ravel()
    label2 = label * y + np.arange(label.size)
    return temp[label2[:].astype(np.int)]


def shuck_boundary(mask, interior):
    """Given the mask and interior of multi, remove the interior labels from
    mask and return the boundary"""
    x, y = mask.shape
    mask = mask.copy()
    assert (x == interior.size)
    temp = mask.ravel()
    label2 = interior + y * np.arange(interior.size)
    temp[label2] = 0
    return mask


def vis_unary(E, label, threshold, myimage):
    """Visualisation of what's going on with the data term of a segmentation.
    Creates a new 3x2 figure showing
    1. A line graph of assigned unary costs (fairly useless but systematic flat regions tend to indicate a problem).
    2. A histogram of unary costs.
    3. The associated segmentation.
    4. A heat map showing whether costs are over,equal, or greater than a threshold.
    This is useful, if for example, you have a flat occlusion penalty and want to see where and how often it is being activated.
    5. Log scale heat map of unary costs"""
    label = label.ravel()
    import matplotlib.pyplot as plt
    plt.figure()
    u = unary_cost(E, label)
    plt.subplot(231)
    plt.plot(np.arange(u.size), u)
    plt.subplot(232)
    n, bins, patches = plt.hist(u, 50, range=(0, 20000))
    plt.subplot(233)
    plt.imshow(vis_col_2(myimage, label.reshape(myimage.shape[0], myimage.shape[1])))
    plt.subplot(234)
    new_lab = np.zeros_like(label)
    new_lab[u == threshold] = 2
    new_lab[u > threshold] = 1
    plt.imshow(new_lab.reshape(myimage.shape[0], myimage.shape[1]))
    plt.colorbar()
    plt.subplot(235)
    plt.imshow(np.log(u + 1).reshape(myimage.shape[0], myimage.shape[1]))
    plt.colorbar()


def felz_superpixels(image, k=100, sigma=5):
    """Implementation of the tree based superpixel algorthim of Felzenswalb
    and Huttenlocker described in their IJCV '04 paper.

    The important thing to note is that this is hackable. Edge maps
    are computed in python and can be switched with something
    else.

    Use felz_superpixels_edge(...) for this.
    """
    image = ndimage.gaussian_filter(image, sigma)
    image = np.double(image)
    xedge = (image_whiten(image[0:-1] - image[1:]) ** 2).sum(2)
    yedge = (image_whiten(image[:, 0:-1] - image[:, 1:]) ** 2).sum(2)
    out = np.zeros(image.shape[0] * image.shape[1], dtype=np.double)
    _felz_super(xedge, yedge, out, np.double(k))
    return out


def felz_superpixels_edges(xedge, yedge, k=100):
    """Implementation of the tree based superpixel algorthim of Felzenswalb
    and Huttenlocker described in their IJCV '04 paper.

    Takes arbitary edge weights rather than computing them from a
    Gaussian blurred image.

    Sample (standard) usage:

    image=ndimage.gaussian_filter(image,sigma)
    image=np.double(image)
    yedge=(image_whiten(image[0:-1]-image[1:])**2).sum(2)
    xedge=(image_whiten(image[:,0:-1]-image[:,1:])**2).sum(2)
    felz_superpixels_edges(xedge,yedge, 100)
    """
    out = np.zeros(yedge.shape[0] * xedge.shape[1], dtype=np.double)
    _felz_super(np.double(xedge), np.double(yedge), out, np.double(k))
    return out


def partition_stats(image, labels):
    """Compute 1st and 2nd order moments of partitions for nd-image"""
    assert (image.shape[:2] == labels.shape)
    chan = image.shape[2]
    chanout = 3 + 3 * chan + chan * (chan + 1) / 2
    out = np.zeros((labels.max() + 1, chanout), dtype=np.double)
    _stats(np.double(labels), np.double(image), out)
    return out[:, 1:]


def compact_labels(interior):
    """Eliminates unused labels, returning a vector of models to keep and
    a new interior labelling"""
    keep, interior = np.unique(interior.astype(np.int), return_inverse=True)
    return keep, interior.astype(np.double)

def upper_bound(unary,nhood, overlap_weight):
    """Generates initial solution by minimizing upper bound\n.
    returns interior followed by upper and lower bound estimate"""
    mask=nhood!=-1
    new_nhood=nhood*mask
    u=unary.copy()
    u2=np.empty_like(unary)
    for i in xrange(nhood.shape[1]):
        u2[:]=unary[:,new_nhood[:,i]]
        u2*=mask[:,i]
        if overlap_weight!=1:
            u2*=overlap_weight
        u+=u2
    guess=np.argmin(u,0)
    cost=u[(guess,np.arange(guess.size))].sum()
    return guess, cost, cost/(1.0+(nhood.shape[1]*overlap_weight))

def mask_from_interior(interior,nhood, overlap_weight):
    """Does what it says"""
    ones=nhood!=-1
    new_nhood=nhood*ones
    mask=np.zeros((interior.size[0],np.max(interior)+1))
    for i in xrange(nhood.shape[1]):
        u+=unary[:,new_nhood[:,i]]*mask[:,i]*overlap_weight
    guess=np.argmin(u,0)
    cost=u[(guess,np.arange(guess.size))].sum()
    return guess, cost, cost/(1.0+(nhood.shape[1]*overlap_weight))

def standard_loop(discrete, cont, interior, cost, max_it=5, checking=True):
    """Generic code for implementing the standard alternation loop
    where you minimize a labelling, refit and then minimize the labelling
    again.\n
    Takes three functions as inputs.\n
    Discrete that only takes
    interior as an input, and returns a new mask, and interior labelling.
    \n
    Cont takes a mask as input and returns nothing, just updates the internal
    state used by other functions.
    \n
    cost takes a mask as input and returns the cost \n
    max_iterations, debug testing and diagnostic messages are handled by
    default
    """
    old_cost = np.Infinity
    new_cost = 0
    it = 0
    while (old_cost > new_cost and it < max_it):
        if it != 0:
            old_cost = new_cost
        mask, interior = discrete(interior)
        if checking:
            new_cost = cost(mask)
            print "Discrete optimisation changed cost to : " + str(new_cost)
            assert (new_cost <= old_cost)
        keep, interior = compact_labels(interior)
        if checking:
            print str(keep.shape[0])+"models left"
        mask = mask[:, keep]
        cont(mask, keep)
        new_cost = cost(mask)
        if checking:
            print "Continious optimisation changed cost to : " + str(new_cost)
            if (new_cost >= old_cost):
                import warnings
                warnings.warn("Cont. optimisation increased cost from: " + str(old_cost) + " to " + str(new_cost))
        it = it + 1
    return mask, interior


def build_nhood(coarse, size=10):
    """Build neighbourhood from initial coarse representation"""
    from sklearn.neighbors import NearestNeighbors
    coarse = coarse.reshape(coarse.shape[0], -1)
    nbrs = NearestNeighbors(n_neighbors=size + 1, algorithm='ball_tree').fit(coarse)
    _, indices = nbrs.kneighbors(coarse)
    return indices  # [:,1:]


def _filter(*args):
    return _segmentation._filter(*args)


_filter = _segmentation._filter


def _filter_sum(*args):
    return _segmentation._filter_sum(*args)


_filter_sum = _segmentation._filter_sum


def _multi(*args):
    return _segmentation._multi(*args)


_multi = _segmentation._multi


def _all_gc_thresh(*args):
    return _segmentation._all_gc_thresh(*args)


_all_gc_thresh = _segmentation._all_gc_thresh


def _multi_thresh(*args):
    return _segmentation._multi_thresh(*args)


_multi_thresh = _segmentation._multi_thresh


def _allgc(*args):
    return _segmentation._allgc(*args)


_allgc = _segmentation._allgc


def _expand(*args):
    return _segmentation._expand(*args)


_expand = _segmentation._expand


def _kmeans(*args):
    return _segmentation._kmeans(*args)


_kmeans = _segmentation._kmeans


def _vis(*args):
    return _segmentation._vis(*args)


_vis = _segmentation._vis


def _vis_col(*args):
    return _segmentation._vis_col(*args)


_vis_col = _segmentation._vis_col


def _vis_col_2(*args):
    return _segmentation._vis_col_2(*args)


_vis_col_2 = _segmentation._vis_col_2


def _mdl(*args):
    return _segmentation._mdl(*args)


_mdl = _segmentation._mdl


def _clump(*args):
    return _segmentation._clump(*args)


_clump = _segmentation._clump


def _shrink(*args):
    return _segmentation._shrink(*args)


_shrink = _segmentation._shrink


def _felz_super(*args):
    return _segmentation._felz_super(*args)


_felz_super = _segmentation._felz_super


def _MST(*args):
    return _segmentation._MST(*args)


_MST = _segmentation._MST


def _stats(*args):
    return _segmentation._stats(*args)


_stats = _segmentation._stats


def _MST_8(*args):
    return _segmentation._MST_8(*args)


_MST_8 = _segmentation._MST_8


def _correspondPixels(*args):
    return _segmentation._correspondPixels(*args)


_correspondPixels = _segmentation._correspondPixels
# This file is compatible with both classic and new-style classes.
